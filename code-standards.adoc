
= Code Standards
This guide defines coding conventions for projects using Clean Architecture and Domain-Driven Design (DDD) principles.
- To ensure maintainability, testability, and scalability of the `OrdersApi` project, we apply Clean Architecture principles combined with Domain-Driven Design (DDD). 
- This approach organizes code by business domain and separates concerns clearly across layers.
- All layers are implemented within the same project for simplicity using naming conventions standard to .NET applications:
- This structure encourages separation of concerns, facilitates unit testing, and allows the system to grow without becoming monolithic or tightly coupled.

== Folder structure
[source]
----
OrdersApi/
├── API/                             // Presentation layer (entry point)
│   ├── Controllers/                 // API controllers (HTTP endpoints)
│   └── Models/                      // API request and response models
│
├── Application/                      // Application layer orchestrating use cases and rules
│   ├── Abstractions/                 // Interfaces (e.g., IOrderService, IOrderQuery)
│   ├── Services/                     // Implementations of application services
│   ├── Queries/                      // Projection-based data access (read side)
│   └── DTOs/                         // Data Transfer Objects for input/output across layers
│
├── Domain/                           // Core business logic and domain model
│   ├── Entities/                     // Main domain entities (e.g., Order, User)
│   ├── ValueObjects/                // Immutable value types (e.g., Address)
│   ├── Enums/                        // Domain-specific enumerations (e.g., OrderStatus)
│   └── Abstractions/                // Domain service interfaces and domain policies
│
├── Infrastructure/                   // Implementations of technical details
│   ├── Data/                         // EF Core DbContext and configurations
│   │   ├── Configurations/          // EntityTypeConfigurations (e.g., OrderConfiguration)
│   │   ├── Repositories/            // Repository implementations (e.g., OrderRepository)
│   │   └── Migrations/              // EF Core database migrations
│   └── Integrations/                // Integrations with external services (e.g., payment gateway)
│
├── Common/                           // Shared cross-cutting utilities and helpers
│   ├── Exceptions/                  // Custom exception classes
│   ├── Extensions/                  // Extension methods for cleaner code
│   └── Utilities/                   // General-purpose helpers and utility functions
----
 
== Naming Conventions (Extended with Clean Code Principles)

=== General Principles
- *Be descriptive and unambiguous.* Names should reveal intent.
- *Avoid disinformation.* Don’t use names that could be misleading (e.g., `list` for a variable that is actually a map).
- *Use pronounceable names.* E.g., `customerAddress` instead of `custAddr`.
- *Use searchable names.* Avoid single-letter or overly short names (e.g., prefer `orderTotal` over `ot`).
- *Avoid encoding type or scope into names.* Let the type system speak for itself.
- *Use consistent naming across the codebase.*
- *Use file scoped namespace in all classes*

=== Classes, Methods, and Properties
- Use *PascalCase* (e.g., `OrderService`, `CalculateTotal`).
- Name *classes* as *nouns or noun phrases* (e.g., `InvoiceGenerator`, `UserRepository`).
- Name *methods* as *verbs or verb phrases* (e.g., `GetUserById`, `ProcessPayment`).
- Use *Boolean method names* that imply true/false (e.g., `IsAvailable`, `HasPermission`).
- Properties should be named like their underlying data (e.g., `FirstName`, `CreatedAt`).

=== Local Variables and Parameters
- Use *camelCase* (e.g., `orderId`, `customerEmail`).
- Choose *descriptive names* based on purpose, not type (e.g., `startDate` over `date1`).
- Use *short names* (e.g., `i`, `j`, `k`) only in *small, tightly scoped loops*.

=== Interfaces
- Prefix with `I` (e.g., `IUserService`, `IEmailSender`).
- Interface names should describe *capabilities or roles* (e.g., `ILogger`, `ICacheable`).

=== Constants and Enums
- Use *PascalCase* for enums and enum values (e.g., `OrderStatus.Pending`).
- Enum names should be *singular* (e.g., `Color`, not `Colors`).


== DDD Best Practices

- Entities should contain behavior, not just data.
- Use **value objects** where applicable.
- Repositories belong to the **domain interface layer**, implementations in infrastructure.
- Services should represent **application use cases**, not utility logic.

== Dependency Injection

- Use constructor injection for all dependencies.
- Register dependencies in `Startup.cs` or `Program.cs` (via IServiceCollection).

== Event Handling

- Use **Transactional Outbox** pattern to publish events after transactions.
- Events must be immutable.
- Consumers should be idempotent (use CorrelationId).

== General Rules

- No business logic in controllers — delegate to Application layer.
- Use async/await for all I/O operations.
- Avoid static utility classes unless absolutely necessary.
- Keep methods short and focused — ideally under 20 lines.



== Entity class layout

Each class must follow this structure:

1. `using` statements
2. `namespace` file scope declaration
3. XML `<summary>` comment for the class
4. Class declaration
5. Fields and properties
6. Constructors
7. Methods (public first, then private)
8. Events or handlers (if applicable)

Example:

[source,csharp]
----
namespace OrdersApi.Domain.Entities;

public class Order
{
    private Order() { } // EF Core requires a parameterless constructor

    public Order(Guid id, Guid userId, string status, string products, decimal total)
    {
        if (id == Guid.Empty)
            throw new ArgumentException("Id cannot be empty.", nameof(id));
        if (userId == Guid.Empty)
            throw new ArgumentException("UserId cannot be empty.", nameof(userId));
        if (string.IsNullOrWhiteSpace(status))
            throw new ArgumentException("Status cannot be null or whitespace.", nameof(status));
        if (string.IsNullOrWhiteSpace(products))
            throw new ArgumentException("Products cannot be null or whitespace.", nameof(products));
        if (total < 0)
            throw new ArgumentOutOfRangeException(nameof(total), "Total cannot be negative.");

        Id = id;
        UserId = userId;
        Status = status;
        Products = products;
        Total = total;
    }

    public Guid Id { get; private set; }
    public Guid UserId { get; private set; }
    public string Status { get; private set; }
    public string Products { get; private set; }
    public decimal Total { get; private set; }

    public override bool Equals(object obj)
    {
        if (ReferenceEquals(this, obj))
            return true;
        if (obj is null || GetType() != obj.GetType())
            return false;

        var other = (Order)obj;
        return Id == other.Id;
    }

    public override int GetHashCode()
    {
        return Id.GetHashCode();
    }

    public static bool operator ==(Order left, Order right)
    {
        if (ReferenceEquals(left, right))
            return true;
        if (left is null || right is null)
            return false;
        return left.Id == right.Id;
    }

    public static bool operator !=(Order left, Order right)
    {
        return !(left == right);
    }

    // Add behavior here (DDD principle)
}
----